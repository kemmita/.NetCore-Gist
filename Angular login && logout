1. First Create the User Model
namespace DatingApp.API.models
{
    public class User
    {
        public int Id { get; set; }
        public string UserName {get; set;}
        public byte[] PasswordHash {get; set;} 
        public byte[] PasswordSalt {get; set;}
    }
}
2. We then need to create a repository pattern within our application, place the repository classes inside of the data folder
we will first need to create the Interdace for the repository
using System.Threading.Tasks;
using DatingApp.API.models;

namespace DatingApp.API.data
{
    public interface IAuthRepository
    {
         Task<User> Register(User user, string password);
         Task<User> Login(string username, string password);
         Task<bool> UserExists(string username);
    }
}

3. After Creating the interface we then need to create the actual repository
using System;
using System.Threading.Tasks;
using DatingApp.API.Data;
using DatingApp.API.models;
using Microsoft.EntityFrameworkCore;

namespace DatingApp.API.data
{
  public class AuthRepository : IAuthRepository 
  {
      private readonly DataContext _context;
      public AuthRepository (DataContext context)
      {
          _context = context;
      }
    public async Task<User> Login(string username, string password)
    {
      var user = await _context.Users.FirstOrDefaultAsync(x => x.UserName == username);
      if(user == null){
          return null;
      }
      if(!VerifyPasswordHash(password, user.PasswordHash, user.PasswordSalt)){
          return null;
          
      }
      return user;
      
    }

  private bool VerifyPasswordHash(string password, byte[] passwordHash, byte[] passwordSalt)
    {
       using (var hmac = new System.Security.Cryptography.HMACSHA512(passwordSalt)){
         var computedHash = hmac.ComputeHash(System.Text.Encoding.UTF8.GetBytes(password));
         for(int i = 0; i < computedHash.Length; i++){
             if(computedHash[i] != passwordHash[i]){
                return false;
             }
         }
         return true;
     }
    }
 
 
 4. before we create our login method within the controller we will need to create the UserForLoginDto file, this will go into a Dtos folder
 
 namespace DatingApp.API.Dtos
{
    public class UserForLoginDto
    {
        public string UserName { get; set; }
        public string Password { get; set; }
    }
}

 
 
 5.. Now we go to the AuthController that will use the repository above and not the dbcontext, the context was used in the repo above
 using System;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using System.Threading.Tasks;
using DatingApp.API.data;
using DatingApp.API.Data;
using DatingApp.API.Dtos;
using DatingApp.API.models;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Configuration;
using Microsoft.IdentityModel.Tokens;

namespace DatingApp.API.Controllers
{
   
    [Route("api/[controller]")]
    public class AuthController : Controller
    {
       private readonly IAuthRepository _repo;
       private readonly IConfiguration _config;
        public AuthController(IAuthRepository repo, IConfiguration config)
        {
            _repo = repo;
            _config = config;
        }
        [HttpPost("login")]
        public async Task<IActionResult> Login([FromBody]UserForLoginDto userForLoginDto){
            var userFromRepo = await _repo.Login(userForLoginDto.UserName.ToLower(), userForLoginDto.Password);

            if(userFromRepo == null){
                return Unauthorized();
            }

            var tokenHandler = new JwtSecurityTokenHandler();
            var key = Encoding.ASCII.GetBytes(_config.GetSection("AppSettings:Token").Value);
            var tokenDescriptor = new SecurityTokenDescriptor{
                Subject = new ClaimsIdentity(new Claim[]
                {
                    new Claim(ClaimTypes.NameIdentifier, userFromRepo.Id.ToString()),
                    new Claim(ClaimTypes.Name, userFromRepo.UserName)
                }),
                Expires = DateTime.Now.AddDays(1),
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha512Signature)


            };
            var token = tokenHandler.CreateToken(tokenDescriptor);
            var tokenString = tokenHandler.WriteToken(token);

            return Ok( new {tokenString});
        
        }
        
    }
}

6. We then must go into our Startup.cs file to specify the authetication process
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using DatingApp.API.data;
using DatingApp.API.Data;
using Microsoft.AspNetCore.Authentication.JwtBearer;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Microsoft.IdentityModel.Tokens;

namespace DatingApp.API
{
    public class Startup
    {
        public Startup(IConfiguration configuration)
        {
            Configuration = configuration;
        }

        public IConfiguration Configuration { get; }

        // This method gets called by the runtime. Use this method to add services to the container.
        public void ConfigureServices(IServiceCollection services)
        {
            var key = Encoding.ASCII.GetBytes(Configuration.GetSection("AppSettings:Token").Value);
            services.AddDbContext<DataContext>(x => x.UseSqlite(Configuration.GetConnectionString("DefaultConnection")));
            services.AddMvc();
            services.AddCors();
            services.AddScoped<IAuthRepository,  AuthRepository>();
            services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
            .AddJwtBearer(options => {
                options.TokenValidationParameters = new TokenValidationParameters{
                    ValidateIssuerSigningKey = true,
                    IssuerSigningKey = new SymmetricSecurityKey(key),
                    ValidateIssuer = false,
                    ValidateAudience = false,

                };
            });
            
        }

        // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.
        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            if (env.IsDevelopment())
            {
                app.UseDeveloperExceptionPage();
            }
            app.UseCors(x => x.AllowAnyHeader().AllowAnyMethod().AllowAnyOrigin().AllowCredentials());
            app.UseAuthentication();
            app.UseMvc();
        }
    }
}


7. Now we will move from our .net code to our angular code, first go into the app.modules.ts file as we will need to import
FormsModule, HttpModule, and AuthService

import { FormsModule } from '@angular/forms';
import { HttpModule } from '@angular/http';
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';

import { AppComponent } from './app.component';
import { ValueComponent } from './value/value.component';
import { NavComponent } from './nav/nav.component';
import { AuthService } from './_services/auth.service';



@NgModule({
  declarations: [
    AppComponent,
    ValueComponent,
    NavComponent
],
  imports: [
    BrowserModule,
    HttpModule,
    FormsModule
  ],
  providers: [
    AuthService
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }

8.now in the app folder create another folder labeled _services and add a file called auth.service.ts
import { Http, Headers, RequestOptions, Response } from '@angular/http';
import { Injectable } from '@angular/core';
import 'rxjs/add/operator/map';
@Injectable()
export class AuthService {
  BaseUrl = 'http://localhost:5000/api/auth/';
  userToken: any;
constructor(private http: Http) {}
  login(model: any) {
    const headers = new Headers({'Content-type': 'application/json'});
    const options = new RequestOptions({headers: headers});
    return this.http.post(this.BaseUrl + 'login', model, options).map((response: Response) => {
      const user = response.json();
      if (user) {
        localStorage.setItem('token', user.tokenString);
        this.userToken = user.tokenString;
      }
    });
  }

}

9.now create a new component and in the ts file use the service we just created
import { Component, OnInit } from '@angular/core';
import { AuthService } from '../_services/auth.service';

@Component({
  selector: 'app-nav',
  templateUrl: './nav.component.html',
  styleUrls: ['./nav.component.css']
})
export class NavComponent implements OnInit {
model: any = {};
  constructor(private authService: AuthService) { }

  ngOnInit() {
  }

  login() {
    this.authService.login(this.model).subscribe(data => {
      console.log('Alles ist gut');
    }, error => {
      console.log('Probelm');
    });
  }
}

10. now use the component html to call on the login method
<nav class="navbar navbar-inverse">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#">Dating App</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
          <li><a href="#">Matches</a></li>
          <li><a href="#">Lists</a></li>
          <li><a href="#">Messages</a></li>
      </ul>

      <form #loginForm="ngForm" class="navbar-form navbar-right" (ngSubmit)="login()">
        <div class="form-group">
          <input type="text" placeholder="Username" class="form-control" required name="username" [(ngModel)]="model.username">
        </div>
        <div class="form-group">
          <input type="password" placeholder="Password" class="form-control" required name="password" [(ngModel)]="model.password">
        </div>
        <button type="submit" [disabled]="!loginForm.valid" class="btn btn-success">Sign in</button>
      </form>

    </div>
  </div>
</nav>


11. Looking at logging out, using the same component we used to login, we will use to write the logout methods
import { Component, OnInit } from '@angular/core';
import { AuthService } from '../_services/auth.service';

@Component({
  selector: 'app-nav',
  templateUrl: './nav.component.html',
  styleUrls: ['./nav.component.css']
})
export class NavComponent implements OnInit {
model: any = {};
  constructor(private authService: AuthService) { }

  ngOnInit() {
  }

  login() {
    this.authService.login(this.model).subscribe(data => {
      console.log('Alles ist gut');
    }, error => {
      console.log('Probelm');
    });
  }

  logout() {
    this.authService.userToken = null;
    localStorage.removeItem('token');
    console.log('Logged out');
  }

  loggedIn() {
      const token = localStorage.getItem('token');
      return !!token;
  }


}
12. below we will use the same html component as above, only we added a bit mor functionality to  it.
<nav class="navbar navbar-inverse">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="#">Dating App</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
          <li><a href="#">Matches</a></li>
          <li><a href="#">Lists</a></li>
          <li><a href="#">Messages</a></li>
      </ul>

      <ul *ngIf="loggedIn()" class="nav navbar-nav navbar-right">
        <li><a (click)="logout()">Link</a></li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Welcome User<span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li><a href="#"><i class="fa fa-user"></i>Edit Profile</a></li>
            <li role="separator" class="divider"></li>
            <li><a (click)="logout()"><i class="fa fa-sign-out"></i>Logout</a></li>
          </ul>
        </li>
      </ul>

      <form *ngIf="!loggedIn()"  #loginForm="ngForm" class="navbar-form navbar-right" (ngSubmit)="login()">
        <div class="form-group">
          <input type="text" placeholder="Username" class="form-control" required name="username" [(ngModel)]="model.username">
        </div>
        <div class="form-group">
          <input type="password" placeholder="Password" class="form-control" required name="password" [(ngModel)]="model.password">
        </div>
        <button type="submit" [disabled]="!loginForm.valid" class="btn btn-success">Sign in</button>
      </form>

     

    </div>
  </div>
</nav>

